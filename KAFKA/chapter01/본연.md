# Kafka Study 1장 - 카프카 시작하기

## 1.1 발행 / 구독 메시지 전달
- 발행 : 전송자, writer, 쓰는쪽
- 구독 : 수신자, reader, 읽는쪽
> 발행 / 구독 메시지 전달 패턴은 발신하는 쪽에서 수신하는 쪽으로 **직접** 전달하지 않는 것   
> 중간의 거점 역할을 하는 **브로커(메시지 서버)** 가 존재


### 1.1.1 초기의 발행 / 구독 시스템
- 가운데 간단한 메시지 큐나 프로세스 간 통신 채널을 놓는 경우
### 1.1.2 개별 메시지 큐 시스템
- 개별 메시지 큐가 늘어나면서 중복이 발생하고, 다수의 큐를 따로 관리하면 유지보수에 어려움이 존재
- 추후 비즈니스가 확장됨에 따라, 개별 메시지 큐가 아닌 중앙 집중된 메시지 큐 필요성 나타남

## 1.2 카프카 입문
- 분산 커밋 로그  or 분산 스트리밍 플랫폼
    - 스트리밍 특징
        - 지속적인 데이터 처리 <-> 일괄 처리 (Batch Processing)
        - 이벤트 기반
        - 유연한 데이터 전달 (1회 or N회 사용 가능)
- 파일 시스템이나 데이터베이스 커밋 로그란?
    - 데이터의 변화 = 등록, 수정, 삭제 이벤트
### 1.2.1 메시지와 배치
- 메시지 : 카프카에서 **데이터의 기본 단위**
    - DB 에서의 row 나 record
    - 단순 바이트 배열로 데이터의 형식이나 의미가 없다.
    - 키(Key) : 메시지를 저장할 파티션을 결정하기 위해 사용
- 배치 : 메시지를 효율적으로 저장하기 위한 메시지들의 집합
    - 한건 한건의 메시지를 보내는 것은 오버헤드를 발생시킹
    - 배치 크기가 커질수록 시간당 처리되는 메시지 증가 -> 각각 메시지가 전달되는 시간 증가
### 1.2.2 스키마
- 단순 바이트 배열의 메시지에 내용을 이해할 수 있도록 구조(혹은 스키마) 부여
- JSON, XML은 스키마 버전 간의 호환성 유지 기능이 떨어짐
- Avro 를 주로 사용
    - 메시지 본체와 스키마를 분리 -> 스키마가 변경되어도 코드 변경을 안해도 됨
    - 강력한 데이터 타이핑과 스키마 변경에 따른 호환성이 좋음
### 1.2.3 토픽과 파티션
#### 토픽 : 카프카에서 데이터를 구분하는 논리적인 이름
- 메시지의 카테고리로 이해할 수 있다.
- 메시지는 특정 토픽에 기록
- 토픽에 저장된 메시지는 카프카 브로커의 디스크에 저장되어 기간이나 용량 설정에 따라 유지됨
#### 파티션 : 토픽을 물리적으로 나눈 단위
- 분산성 : 여러 브로커에 분산 저장하여 대량의 데이터를 처리
- 순서 보장 : 각 파티션 내부에 메시지가 순서대로 저장되나, 다른 파티션 간에 순서는 보장되지 않는다.
- 확장성 : 파티션 수를 늘려 토픽의 처리량을 늘릴 수 있다.
- 파티션 키 : 특정 파티션에 할당하고 할 때 사용, 키를 저장하지 않으면 라운드 로빈 방식으로 메시지 분배
> 라운드 로빈 방식 : 들어온 순서대로 우선순위를 할당하는 방식
### 1.2.4 프로듀서와 컨슈머
#### 프로듀서 : 데이터를 카프카의 특정 토픽에 게시하는 역할을 하는 서비스
- 작동 방식
    1. 메시지 전송
        - 특정 토픽에 데이터를 전송
    2. 파티션 지정
        - 파티션 키 O: 해싱 알고리즘에 따라 파티션 선택
        - 파티션 키 X: 라운드 로빈 방식으로 파티션 선택
- 특징
    - 분산 처리 : 여러 프로듀서가 병렬롤 데이터를 전송할 수 있어 확장성이 좋음
    - 내구성 : 데이터는 브로커에 저장되고 복제되어 데이터 손실 가능성이 낮다.
    - 전송 옵션 :
        - acks=0 전송 확인 없음
        - acks=1 리더 브로커가 데이터 수신 확인
        - acks=all 모든 복제 브로커가 데이터를 확인
#### 컨슈머 : 특정 토픽에서 데이터를 읽고 처리하는 역할을 하는 서비스
- 작동 방식
    1. 토픽 구독
        - 컨슈머는 하나 이상의 토픽을 구독
    2. 메시지 읽기
        - 기본적으로 오프셋을 기준으로 데이터를 순차적으로 소비
        - 오프셋 : 파티션 내 메시지의 고유한 위치를 나타냄
    3. 오프셋 관리
        - 메시지를 처리한 뒤, 마지막으로 읽은 오프셋을 커밋하여 다음 메시지를 읽도록 관리
- 특징
    - 컨슈머 그룹
        - 컨슈머는 컨슈머 그룹이라는 논리적 단위로 묶일 수 있음
        - 같은 컨슈머 그룹에 속하면 다른 파티션을 읽어 병렬 처리가 가능
        - 외부 다른 컨슈머 그룹은 동일한 메시지를 독립적으로 읽을 수 있다.
    - 오프셋 관리
        - 자동 커밋 또는 수동 커밋을 통해 처리 상태를 저장
    - 재처리 기능
        - 필요시 오프셋을 재설정하여 과거 메시지를 다시 읽을 수 있음
### 1.2.5 브로커와 클러스터
#### 브로커 : 카프카 클러스터에서 동작하는 하나의 서버 인스턴스로, 메시지를 저장하고 요청를 처리하는 단위
- 역할
    - 데이터 저장
        - 프로튜서가 전달한 메시지를 디스크에 저장
        - 지정된 보관 기간동안 메시지 유지
    - 요청 처리
        - 프로듀서로부터 데이터를 수신하고, 이를 적절한 파티션에 저장
        - 컨슈머의 요청에 따라 데이터를 전달
    - 복제 관리
        - 파티션 데이터를 다른 브로커에 복제
        - 복제본 중 하나가 리더로 지정되어 읽기 쓰기 요청을 처리하고, 나머지는 팔로워로 작동
- 특징
    - 분산처리 : 여러 브로커가 병렬로 작동, 데이터 분산 저장 및 처리
    - 확장성 : 브로커를 추가함으로써 클러스터의 저장 용량과 처리량 증가 가능
    - 고가용성 : 브로커 중 하나가 장애를 겪어도 다른 브로커가 데이터를 복구하거나 대체 작업 수행

#### 클러스터 : 여러 브로커의 집합, 카프카 전체 시스템
- 구성
    - 최소 1개 이상의 브로커로 구성
    - 클러스터는 데이터를 분산 처리하고 고가용성을 보장
- 작동 방식
    - 메타데이터 관리
        - 클러스터 내 브로커와 파티션 정보는 주키퍼 또는 카프카 내장 메타 스토어가 관리
    - 리더와 팔로워
        - 특정 브로커가 리더 역할을 하며 읽기/쓰기 요청을 처리
        - 다른 브로커는 복제 데이터를 유지하며 리더 장애 시 대체
    - 분산 저장
        - 토픽의 각 파티션은 클러스터 내 여러 브로커에 분산 저장
- 특징
    - 확장성 : 브로커를 추가하면 클러스터는 자동으로 데이터와 작업을 분산 처리
    - 내결함성 : 하나의 브로커가 장애를 겪어도 다른 브로커가 복제 데이터 기반으로 작동하여 데이터 손실을 방지
### 1.2.6 다중 클러스터
- 카프카 미러메이커
    - 카프카에서 기본적으로 제공하는 도구
    - 데이터를 다른 클러스터로 전달하거나 양방향 복제를 설정 가능
    - 제한사항
        - 네트워크 대역폭에 영향을 받을 수 있음
        - 데이터 지연이 발생할 수 있음




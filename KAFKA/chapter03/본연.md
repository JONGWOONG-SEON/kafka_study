# 카프카 프로듀서
- 카프카 공식 클라이언트는 java, scala
- Kafka 서드 파티 클라이언트 장단점 비교

| **언어**       | **클라이언트**            | **장점**                                   | **단점**                                |
|----------------|--------------------------|------------------------------------------|---------------------------------------|
| Python         | confluent-kafka-python   | 고성능, Confluent와의 통합              | 설정이 약간 복잡, 외부 C 라이브러리 필요 |
| Python         | kafka-python             | 설치 간단, 순수 Python                  | 성능 낮음                              |
| Go             | Sarama                   | Go 언어 특성 활용, 고성능                | 복잡한 설정 필요                       |
| Go             | confluent-kafka-go       | 고성능, Confluent와의 통합              | `librdkafka` 의존                      |
| JavaScript     | kafkajs                  | 순수 JS 구현, 비동기 처리 지원          | 성능 한계                              |
| C++            | cppkafka                 | 고성능, 유연성                           | 초기 설정 복잡                          |
| .NET           | confluent-kafka-dotnet   | Confluent와의 완벽 통합                  | 설정 복잡                              |

## 3.1 프로듀서 개요
1.카프카에 메시지를 쓰는 작업은 **ProducerRecord** 객체를 생성함으로 시작
- 필수 : 토픽, 벨류
- 옵션 : 키, 파티션

2.ProducerRecord 를 전송하는 API 를 호출했을 때 가장 먼저 하는 일
- 키와 값 객체가 네트워크 상 전달 될 수 있도록 직렬화해서 바이트 배열로 변환하는 과정
- 파티션을 명시적으로 지정하지 않으면 해당 데이터를 파티셔너에게 전달
- 파티셔너는 파티션을 결정하는 역할 -> 기준은 ProducerRecord 객체의 키

3.메시지가 전송될 토픽과 파티션이 결정되면 프로듀서는 이 레코드를 같은 토픽 파티션으로 전송될 레코드 배치에 추가

4.별도의 메시지 스레드가 레코드 배치를 브로커에 전송

## 3.2 카프카 프로듀서 생성하기
### 카프카 필수 속성값
- bootstrap.servers
    - 프로듀서가 사용할 브로커 목록
    - 모든 브로커를 작성할 필요 없음 -> 첫 연결 뒤 추가 정보를 받아오기 때문에
    - 최소 2개 이상의 브로커를 지정할 것
- key.serializer
    - 키의 값을 직렬화하기 위해 사용하는 시리얼라이저 클래스
- value.serializer
    - 벨류값을 직렬화하기 위해 사용하는 시리얼라이저 클래스

### 메시지 전송 방법
- 파이어 앤 포겟
    - 메시지를 서버에 전송만 하고 신경쓰지 않음
    - 메시지 유실 가능성 높음
- 동기적 전송
    - 카프카 프로듀서는 언제나 비동기적으로 작동
    - 다음 메시지를 전송하기 전에 get() 메서드를 호출
    - 작업이 완료될 때까지 기다린다
- 비동기적 전송
    - 카프카의 브로커로부터 응답을 받는 시점에서 자동으로 콜백함수 호출

## 3.3 카프카로 메시지 전달하기
- 책에서는 ProducerRecord 객체로 진행을 하지만, 실제로는 KafkaTemplate을 사용하여 레코드 정보를 전달함

### ProducerRecord 와 KafkaTemplate 차이점 요약

| **특징**                  | **ProducerRecord**                       | **KafkaTemplate**                  |
|---------------------------|------------------------------------------|-------------------------------------|
| **역할**                  | 메시지 데이터를 캡슐화                  | 메시지 전송을 간소화하는 유틸리티   |
| **제공 방식**             | Kafka Java Native API                   | Spring Kafka 고수준 API            |
| **구현 복잡성**           | 사용자가 모든 세부 사항 직접 관리        | Spring에서 내부적으로 처리          |
| **사용 편의성**           | 상대적으로 복잡                         | 간단하고 코드가 간결                |
| **주요 사용 대상**        | KafkaProducer를 직접 사용할 때          | Spring Kafka 기반의 애플리케이션    |
| **비동기 지원**           | 직접 구현 필요                         | 기본 제공 (`addCallback` 사용 가능) |
| **시리얼라이제이션 설정** | 사용자가 직접 설정                     | Spring에서 자동 처리                |

### 3.3.1 동기적으로 메시지 전송하기
- KafkaProducer 의 2가지 에러
    - 재시도 가능한 에러 : 연결 에러
    - 재시도로 해결되지 않는 에러 : 메시지 크기가 큰 경우
-
## 3.4 프로듀서 설정하기
- client.id
    - 프로듀서와 그것을 사용하는 애플리케이션을 구분하기 위한 논리적 식별자
    - 브로커는 프로듀서가 보내온 메시지를 구분하기 위해 사용
    - 사용 예시
        - 브로커가 로그 메시지를 출력할 때
        - 성능 메트릭 값을 집계할 때
        - 클라이언트별로 사용량을 할당할 때
- acks
    - acks=0
        - 성공으로 간주하여 브로커의 응답을 기다리지 않는다
        - 메시지 유실될 수 있음
        - 높은 처리량 작업에 사용
    - acks=1
        - 성공 여부에 대한 응답을 받는다
        - 메시지가 복제가 안된 채로 새 리더가 선출 시 유실 가능성 있음
    - acks=all
        - 메시지가 모든 인-싱크 레플리카에 전달된 뒤에야 성공 응답을 받는다
        - 가장 안전한 형태
        - 지연 시간이 길어짐
- 메시지 전달 시간
  - 
## 3.5 시리얼라이저
- 프로듀서를 설정할 때는 반드시 시리얼라이저를 지정해야함
- 커스텀 시리얼라이저는 변경사항 많은 경우 신경써야할 부분이 많다.
- 아파치 에이브로
    - 언어에 독립적인 스키마 형태로 기술
    - 새로운 스키마와 기존 스키마와의 호환성 유지

## 3.6. 파티션
- 키값이 null인 경우, 레코드는 현재 사용 가능한 토픽의 파티션 중 하나에 랜덤하게 저장
- 파티션별로 저장되는 메시지의 갯수를 맞추기 위해 라운드로빈 알고리즘 사용
-

## 3.7 헤더
- 메시지의 전달 내역을 기록하는 용도
- 데이터가 생성된 곳의 정보를 저장

## 3.8 인터셉터
- ProducerInterceptor
    - ProducerRecord<K,V> onSend(Producer<K,V> record)
        - 프로듀서가 레코드를 보내기 전, 직렬화되기 직전에 호출
        - 메서드에서 유효한 ProducerRecord 를 리턴하도록 주의
    - void onAcknowledgement(RecordMetadata metadata, Exception exception)
        - 브로커가 보낸 응답을 클라이언트가 받았을 때 호출
        - 응답을 변경 할 수 없지만, 정보를 읽을 수 있음

## 3.9 쿼터 스로틀링
- 브로커에서 읽기/쓰기 속도를 제한할 수 있는 기능
1. 쓰기 쿼터
2. 읽기 쿼터
3. 요청 쿼터




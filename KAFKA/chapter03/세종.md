# 카프카 프로듀서: 메시지 쓰기

## 1. 프로듀서 개요
- **역할**: 카프카에 데이터를 쓰는 작업을 수행.
  - 사용자 행동 기록, 성능 메트릭, 데이터베이스 버퍼링, 비동기 통신 등 다양한 목적에 활용.
- **구성 요소**:
  1. **`KafkaProducer` 객체**: 메시지 전송을 담당.
  2. **`ProducerRecord` 객체**: 전송할 메시지의 토픽, 키, 밸류를 포함.
  3. **시리얼라이저**: 키와 값을 직렬화해 바이트 배열로 변환.
  4. **파티셔너**: 메시지를 적절한 파티션에 분배.

---

## 2. 프로듀서 생성

### 필수 속성
1. **`bootstrap.servers`**  
   - 프로듀서가 카프카 클러스터에 연결할 브로커의 `host:port` 목록.
   - 최소 두 개 이상의 브로커를 지정해 연결 안정성 확보.
   
2. **`key.serializer`**  
   - 레코드 키를 바이트 배열로 직렬화하기 위한 클래스.
   - `VoidSerializer` 사용 시 키 없이 값만 보낼 수 있음.
   
3. **`value.serializer`**  
   - 레코드 값을 직렬화하기 위한 클래스.

### 메시지 전송 방식
1. **파이어 앤 포겟**:  
   - 메시지를 전송만 하고 성공 여부는 확인하지 않음.
   - 전송 실패 시 데이터 유실 가능.
   
2. **동기 전송**:  
   - `send()` 메서드 호출 후 `Future.get()`으로 결과 확인.
   - 성공 여부를 명확히 확인 가능하지만, 대기 시간 발생.
   
3. **비동기 전송**:  
   - `send()` 호출 시 콜백 함수 등록.
   - 메시지 전송 성공/실패에 따라 콜백 함수 호출.

---

## 3. 카프카로 메시지 전달

### 에러 처리
1. **재시도 가능한 에러**:
   - 연결 오류, 파티션 리더 변경 등.
   - 자동 재전송으로 해결 가능.
   
2. **재시도 불가능한 에러**:
   - 메시지 크기 초과 등.
   - 예외 즉시 발생.

### 전송 시 동기 vs 비동기
1. **동기 전송**:
   - 전송 완료 확인 후 작업 진행.
   - 대기 시간이 길어 실제 애플리케이션에서는 잘 사용되지 않음.
   
2. **비동기 전송**:
   - 빠른 전송과 효율적 에러 처리 가능.
   - 콜백 등록으로 에러 및 메타데이터 처리.

---

## 4. 프로듀서 설정

### 성능 및 신뢰성 관련 주요 설정
1. **`acks`**  
   - 프로듀서가 전송 성공 여부를 판단하는 기준.
     - `acks=0`: 확인하지 않음. (속도 ↑, 신뢰성 ↓)
     - `acks=1`: 리더 레플리카만 확인.
     - `acks=all`: 모든 인-싱크 레플리카 확인. (속도 ↓, 신뢰성 ↑)
   
2. **`linger.ms`**  
   - 배치를 전송하기 전 대기 시간.  
   - 작은 값일수록 지연 감소, 큰 값일수록 처리량 증가.
   
3. **`batch.size`**  
   - 배치 단위 크기(바이트 기준).  
   - 크기가 작으면 오버헤드 증가, 크기가 크면 메모리 사용 증가.

4. **`compression.type`**  
   - 메시지 압축 방식 (`gzip`, `snappy`, `lz4`, `zstd`).
   - 네트워크 대역폭 및 저장 공간 최적화.

5. **`enable.idempotence`**  
   - 멱등성 활성화로 중복 데이터 저장 방지.
   - 순서 보장 및 데이터 정확성 강화.

### 타임아웃 및 재시도 관련 설정
1. **`max.block.ms`**  
   - 프로듀서가 블록될 수 있는 최대 시간.
   
2. **`delivery.timeout.ms`**  
   - 전송 준비 완료 시점부터 응답까지 대기 가능한 최대 시간.
   
3. **`retries` & `retry.backoff.ms`**  
   - 재전송 횟수와 재전송 간 대기 시간 설정.

---

## 5. 메시지 직렬화

### 커스텀 시리얼라이저
- 복잡한 객체는 사용자 정의 시리얼라이저를 통해 직렬화.
- 에이브로(Avro)와 같은 범용 시리얼라이저 추천:
  - 스키마 기반 직렬화로 호환성 유지.
  - 변경 시 기존 데이터 처리 가능.

---

## 6. 파티션 할당

### 파티셔너의 역할
- 메시지를 적절한 파티션에 배치.
- **기본 동작**:
  - 키가 없으면 라운드 로빈으로 배치.
  - 키가 있으면 해싱 결과에 따라 특정 파티션에 저장.

### 커스텀 파티셔너
- 특정 로직으로 파티션을 할당해야 하는 경우 직접 구현 가능.

---

## 7. 레코드 헤더
- 레코드에 메타데이터를 추가적으로 포함 가능.
- **활용 사례**:
  - 메시지 출처 추적.
  - 라우팅 정보 저장.

---

## 8. 인터셉터
- 메시지 전송 전/후 동작을 수정하거나 추가하는 데 사용.
- **활용 사례**:
  - 표준 헤더 삽입.
  - 민감 정보 제거.
  - 로깅 및 모니터링.

---

## 9. 쿼터 및 스로틀링
- 브로커에 데이터 전송 속도 제한 가능.
- 설정 항목:
  1. 쓰기 쿼터: 클라이언트당 초당 쓰기 바이트 제한.
  2. 읽기 쿼터: 클라이언트당 초당 읽기 바이트 제한.
  3. 요청 쿼터: 브로커 처리 비율 제한.
- 제한 초과 시:
  - 프로듀서의 버퍼가 차고 `TimeoutException` 발생 가능.

---

## 요약
- 카프카 프로듀서는 신뢰성, 성능, 데이터 처리량을 조율하며 메시지를 전송하는 핵심 구성 요소.
- 설정을 통해 애플리케이션 요구 사항에 맞게 성능 최적화 가능.
- 멱등성, 압축, 직렬화와 같은 기능을 적극 활용하면 안정적이고 효율적인 데이터 전송 가능.

# Chapter06
### 클러스터 멤버십
- 브로커 고유 식별자는 설정파일 정의 혹은 자동 생성 고유식별자를 가진다.
- 브로커 프로세스는 주키퍼에 Ephemeral 노드 형태로 ID 등록
- 브로커 정지 시 Znode 는 삭제 되지만 브로커의 ID는 다른 자료구조로 전이 된다.
---
### 컨트롤러
- 새로운 컨트롤러가 선출되면 컨트롤러 노드에 대한 와치를 생성
- 새 컨트롤러 생성 시 증가된 epoch 값을 전달 받게 되며, 이전 에포크 값에서 요청이 오면 무시하게 된다.
    - 전송 메세지에 컨트롤러 에포크를 포함시켜야 좀바리르 방지 할 수 있다
- 컨트롤러가 선출되면 주키퍼로부터 레플리카 맵을 읽어오는데, 이는 비동기로 수행된다
    - 지연을 줄이기 위해 읽기 수행 시 요청을 분할하여 보냄
- 클러스터 내 브로커가 나갈 시
    - 새로운 브로커를 할당 -> 담당하고 있던 파티션을 새로운 브로커 할당 -> 파티션 리더 선출을 위해 브로커 순회 -> 주키퍼 갱신 -> LeaderAndISR 요청을 통해 다수 파티션에 리더십 정보 갱신
- 파티션 리더들은 클라이언트와 송수신 유지, 파티션 팔로워들은 새 리더 메세지 복제
---
### KRaft
- 주키퍼 기반 컨트롤러 문제점
    - 컨트롤러가 주키퍼에 메타데이터를 쓰는 작업은 동기적으로 이뤄지는데 반해, 브로커 동작은 비동기, 주키퍼 상태업데이트는 비동기적으로 수행되어 메타데이터 불일치 발생
    - 컨트롤러 재시작 시 메타데이터 읽기에 병목이 발생
    - 메타데이터 소유권에 복잡성 상승
- 변경된 설계로 컨트롤러 노드들은 자체적인 리더 선출 가능
- 메타데이터 로그의 리더는 액티브 컨트롤이라 칭하며, 해당 컨트롤러는 모든 RPC 호출을 처리
- 컨트롤러 쿼럼에 최신 상태를 등록 한다.
    - 쿼럼은 컨트롤러로 동작 할 수 있는 브로커 집합
---
### 복제
- 리더 레플리카
    - 모든 쓰기 요청을 처리
- 팔로워 레플리카
    - 별도 설정을 하지 않는 경우 클리어언트 요청 처리 불가
    - 단순히 리더 레플리카 메세지를 복제하여 standby 하는 개념으로 사용
- 리더 레플리카는 팔로워들에 오프셋을 확인하여 인-싱크, 아웃-싱크 레플리카를 구분
- 장애 상황 시 인-싱크 레플리카를 리더로 선출 (선호 리더 방식)
- 불가피할 경우 언클린 리더 선출을 통해 아웃-싱크 레플리카를 리더로 승격
---
### 요청 처리
- 카프카는 TCP 이진 프로토콜을 채택하며, request - response 패턴을 사용
- 네트워크 쓰레드 -> 요청 큐 -> I/O 쓰레드 -> 응답 큐 -> 네트워크 쓰레드 처리
- 쓰기, 읽기 요청은 리더 레플리카로 전송 되어야함
- 클라이언트는 임의 브로커에게 메타데이터를 요청, 캐싱하여 필요 토픽에 파티션 브로커를 찾아냄
---
### 쓰기 요청
- 쓰기 요청 시 유효성 검증 항목
    - 프로듀서가 토픽에 대한 쓰기 권한
    - 요청 acks 설정 유효성
    - acks=all 일 시 프로세스 성공에 유효한 인-싱크 레플리카 수
- 쓰기 요청 유효성 검증이 끝난 후 로컬 디스크에 쓰여짐
- 리눅스에 경우 파일시스템 캐시에 쓰여지며, 디스크 반영 시점을 보장하지 않고 메세지 지속성을 위해 레플리카에 의존
- 파일 시스템 캐시와 페이지 캐시에 동작 차이점?
    - 과거 운영체제에선 파일 시스템 캐시와 페이지 캐시 동작이 별도로 수행 되었음으로 보이나 현재는 페이지 캐시가 파일 시스템 캐시를 대신하여 통합적으로 수행됨
    - 파일 시스템 캐시는 파일 시스템과 운영체제 레벨에서 관리
    - 페이지 캐시는 커널 영역에서 paging memory management 를 통해 실행
---
### 읽기 요청
- 읽기 요청 시 전통적인 데이터베이스와 차이점으로 중간 버퍼를 거치지 않고 바로 네트워크 채널로 전송하여 오버헤드를 없앤다.
- 데이터베이스에서 요청 시 공유 버퍼를 스캔하는 과정이 추가되며 카프카는 이를 없애고 페이지 캐시에서 클라이언트 측으로 응답을 보내는 것으로 보임
- 메타데이터 같은 경우는 세션 캐시를 사용하여 지정 토픽 및 파티션 집합 색인에 오버헤드를 줄인다.
---
### 물리적 저장소
- 카프카 기본 저장 단위는 파티션 레플리카
- 같은 브로커의 서로 다른 디스크 분할 저장 불가능
### 계층화된 저장소
- 로컬, 원격 두 계층으로 분리
- 로컬 계층은 디스크 원격 계층은 HDFS, S3 와 같은 전용 저장소 시스템
- 로컬 계층 보존기간은 짧게 원격 계층 보존기간은 길게 설정
- 이중화된 구조 덕분에 장기간 저장 솔루션에 역할을 수행 할 수 있음
- 원격 계층을 구성함으로써 로컬 페이지 캐시는 온전히 IO 를 수행 할 수 있음
### 파티션 할당
- 레플리카들은 브로커에 고르게 분산
- 각 파티션에 대해 각각의 레플리카는 서로 다른 브로커로 배치
- 랙에 대한 정보?
### 파일 관리
- 하나의 파티션에 대해 여러 개 세그먼트 분할
- 사용되고 있는 세그먼트를 액티브 세그먼트
- 브로커는 각 파티션의 모든 세그먼트에 대해 파일 핸들을 수행함
### 파일 형식
- 각 세그먼트는 하나의 파일 형태로 저장됨
- 로컬, 원격 계층 메세지 형식을 통일함으로써 제로카피 최적화를 수행
- 단일 메세지를 전송 시 또한 배치 단위로 묶음으로써 오버헤드 발생
- 다중 배치 시엔 비용 감소
- 시스템 정보는 배치 단위에 저장되어 레코드간 차이를 파일 형식에 저장함으로써 오버헤드 감소
### 인덱스
- 인덱스는 오프셋과 세그먼트 파일에서 위치를 매핑함
### 압착

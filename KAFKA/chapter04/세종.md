# 카프카 컨슈머: 메시지 읽기

## 1. 컨슈머 개요

### 컨슈머와 컨슈머 그룹
- **컨슈머**: 토픽을 구독하고 메시지를 읽어오는 애플리케이션.
  - 하나의 컨슈머만 사용할 경우, 메시지 처리 속도가 쓰기 속도를 따라가지 못할 수 있음.
  - **컨슈머 그룹**: 여러 컨슈머가 동일한 토픽의 데이터를 분산 처리할 수 있도록 구성.
    - 그룹 내 컨슈머는 각기 다른 파티션에서 메시지를 읽음.
    - 컨슈머 수가 토픽의 파티션 수를 초과해도 추가 컨슈머는 할당받지 못함.

### 리밸런스(Rebalance)
- 파티션이 컨슈머 간에 재할당되는 작업.
- **유형**:
  1. **조급한 리밸런스**:
     - 모든 컨슈머가 파티션 할당을 해제하고 다시 그룹에 참여.
     - 작업이 일시 중단될 수 있음.
  2. **협력적 리밸런스**:
     - 일부 파티션만 재할당하며, 나머지 컨슈머는 작업을 계속 진행.

### 정적 그룹 멤버십
- **`group.instance.id` 설정**으로 컨슈머를 정적 멤버로 등록.
  - 종료 후 재시작 시 기존 파티션을 그대로 할당받아 리밸런스가 발생하지 않음.
  - 동일 `group.instance.id`로 중복 생성 시 에러 발생.
- **활용**:
  - 파티션 기반 로컬 상태 관리 및 캐싱.

---

## 2. 컨슈머 생성

### 필수 설정
1. **`bootstrap.servers`**  
   - 카프카 클러스터의 브로커 정보.  
   - 최소 두 개 이상의 브로커를 지정해 안정성 확보.
   
2. **`key.deserializer`, `value.deserializer`**  
   - 메시지의 키와 값을 바이트 배열에서 자바 객체로 변환.  

3. **`group.id`**  
   - 컨슈머 그룹을 식별하는 ID.
   - 그룹을 지정하지 않으면 단독 컨슈머로 동작.

---

## 3. 토픽 구독

### 구독 방법
- **`subscribe()` 메서드**:
  - 구독할 토픽 목록을 지정하거나 정규식 사용 가능.
  - 그룹에 참여하고 파티션 할당을 시작.

---

## 4. 폴링 루프

### 개념
- **`poll()` 메서드**:
  - 서버에서 새 데이터를 가져오는 단순 루프.
  - **하트비트 전송**: 컨슈머 그룹의 생존 신호로 사용.

### 스레드 안전성
- **“하나의 스레드당 하나의 컨슈머”** 원칙.
  - 한 애플리케이션에서 여러 컨슈머를 사용하려면 각각 별도의 스레드 필요.

---

## 5. 컨슈머 설정

### 주요 설정
1. **데이터 크기와 대기 시간**:
   - **`fetch.min.bytes`**: 컨슈머가 브로커로부터 가져올 최소 데이터 크기.
   - **`fetch.max.wait.ms`**: 최소 데이터 크기가 충족되지 않을 경우 최대 대기 시간.
   - **`fetch.max.bytes`**: 한 번의 폴링에서 가져올 데이터 최대 크기.

2. **파티션 데이터 크기**:
   - **`max.partition.fetch.bytes`**: 파티션당 반환할 최대 데이터 크기.

3. **폴링 설정**:
   - **`max.poll.records`**: 한 번의 폴링에서 반환되는 최대 레코드 수.
   - **`max.poll.interval.ms`**: 폴링 간격 제한 시간.

4. **하트비트와 세션 타임아웃**:
   - **`session.timeout.ms`**: 하트비트가 없을 경우 컨슈머를 그룹에서 제외.
   - **`heartbeat.interval.ms`**: 하트비트 전송 주기. `session.timeout.ms`의 1/3 권장.

5. **오프셋 관리**:
   - **`auto.offset.reset`**:
     - `earliest`: 가장 오래된 메시지부터 읽음.
     - `latest`(기본값): 새 메시지부터 읽음.
   - **`enable.auto.commit`**: 자동 오프셋 커밋 활성화 여부.

6. **네트워크 및 기타**:
   - **`client.id`**: 컨슈머를 식별하기 위한 논리적 ID.
   - **`partition.assignment.strategy`**: 파티션 할당 방식 (Range, RoundRobin 등).
   - **`receive.buffer.bytes`, `send.buffer.bytes`**: TCP 송수신 버퍼 크기.

---

## 6. 오프셋과 커밋

### 오프셋 커밋
- **개념**: 파티션에서 현재 읽고 있는 위치를 업데이트.
- **방식**:
  1. **자동 커밋**:
     - 설정: `enable.auto.commit=true`.
     - 간편하지만 메시지 유실 및 중복 가능성 존재.
  2. **수동 커밋**:
     - 동기(`commitSync`)와 비동기(`commitAsync`) 방식 지원.
     - 동기는 신뢰성 ↑, 비동기는 성능 ↑.

### 특정 오프셋 커밋
- 특정 파티션과 오프셋 맵을 전달하여 선택적으로 커밋 가능.

---

## 7. 리밸런스 리스너

- **역할**: 리밸런싱 시 적절한 정리 작업 수행.
  - 마지막 오프셋 커밋, 자원 해제 등.
- **사용 방법**:
  - **`ConsumerRebalanceListener`** 구현 후 `subscribe()` 호출 시 전달.

---

## 8. 특정 오프셋으로 읽기

### 시작 오프셋 설정
- **`seek()` 메서드**:
  - 지정된 오프셋부터 읽기 시작.
  - `seekToBeginning()`: 파티션 시작점.
  - `seekToEnd()`: 파티션 끝.

---

## 9. 폴링 루프 종료

- **`consumer.wakeup()` 호출**:
  - 폴링 루프를 즉시 중단.
  - 안전한 종료를 위해 `consumer.close()` 호출 필요.

---

## 10. 디시리얼라이저

### 개념
- **역할**: 바이트 배열을 자바 객체로 변환.
- **주의**: 프로듀서와 동일한 시리얼라이저/디시리얼라이저 사용 필수.

### Avro 디시리얼라이저
- **KafkaAvroDeserializer**:
  - 스키마 기반 직렬화 형식으로 데이터 호환성 제공.

---

## 11. 독립 실행 컨슈머

- **필요성**:
  - 특정 파티션만 소비하거나, 리밸런스 기능이 필요 없는 경우.
- **특징**:
  - 직접 파티션을 할당하고 데이터 처리.
  - 리밸런스 자동화 없이 명시적으로 처리.

---

## 요약
- 카프카 컨슈머는 효율적이고 유연한 메시지 소비를 지원.
- 컨슈머 그룹을 활용해 데이터 처리량을 확장 가능.
- 오프셋 관리와 리밸런스 설정은 안정적인 데이터 처리를 위한 핵심 요소.
- 적절한 설정을 통해 메시지 유실과 중복을 방지하고 성능 최적화 가능.
